use sidecar::chunking::languages::{TSLanguageConfig, TSLanguageParsing};

#[tokio::main]
async fn main() {
    let tree_sitter_parsing = TSLanguageParsing::init();
    let language = "rust".to_owned();
    let code = r#"pub fn typescript_language_config() -> TSLanguageConfig {
        TSLanguageConfig {
            // ...
            namespaces: vec![
                "constant", // Constants
                "variable", // Variables
                "property", // Properties
                "parameter", // Parameters
                // functions
                "function", // Functions
                "method", // Methods
                "generator", // Generators
                // types
                "alias", // Type aliases
                "enum", // Enums
                "enumerator", // Enumerators
                "class", // Classes
                "interface", // Interfaces
                // misc.
                "label", // Labels
            ]
            .into_iter()
            .map(|s| s.to_owned())
            .collect(),
            // ...
        }
    }"#;
    let mut parser = tree_sitter::Parser::new();
    let ts_language_config = tree_sitter_parsing
        .for_lang(&language)
        .expect("to be present");
    let grammar = ts_language_config.grammar;
    parser.set_language(grammar()).expect("to work");
    // now we have to figure out the parsing logic here
    let tree = parser.parse(code, None).expect("to parse");
    let node = tree.root_node();
    let source_code = code.as_bytes();
    // lets go with the easy route where its doing some modifictions to the
    // class and then to the methods, so we can figure out how to solve it
    // properly
    // - we want to get an outline of nodes which has classes and their functions
    // - defined and then we can go along with the generated code and try to see
    // - how much of it we can match its all hurestics based, if we have a parsing error
    // - we fail to export or have to figure out some other way to do it (its not deterministic)
    // - classes and their functions

    // First we get the ranges of the classes and then we try to parse the functions
    // which are inside it
    let class_queries = ts_language_config.class_query.to_vec();
    class_queries.into_iter().for_each(|class_query| {
        let query = tree_sitter::Query::new(grammar(), &class_query).expect("to parse");
        let mut cursor = tree_sitter::QueryCursor::new();
        cursor
            .captures(&query, node, source_code)
            .into_iter()
            .for_each(|capture| {
                // We found a class variable in the generated code, so everything inside
                // this can be applied to some functions or something similar
                capture.0.captures.into_iter().for_each(|capture| {
                    let capture_name = query
                        .capture_names()
                        .to_vec()
                        .remove(capture.index.try_into().unwrap());
                    // we have some class nodes, so now lets check for the functions
                    // which can be present in this class declaration and need our attention
                    let range = capture.node.byte_range();
                    let output_string =
                        String::from_utf8(source_code[range.start..range.end].to_vec());
                    dbg!(output_string);
                    // we have to parse the functions which are inside this as well
                })
            });
    });

    let function_bodies = ts_language_config.capture_function_data(&source_code);
    dbg!(function_bodies);
    make_changes_to_functions(code.as_bytes(), vec![].as_slice(), ts_language_config);
}

fn get_function_partial_lines() -> Vec<String> {
    vec![
        "// ...".to_owned(),
        "...".to_owned(),
        "// rest of the code".to_owned(),
    ]
}

/// We assume that we have identified the right function code to append the changes
/// to, we assume that things just match,
/// 1. code generated by gpt thankfully has matching brackets, so we won't be loosing
/// the folds which are present
/// 2. we are okay with messing up the indentation here, we will fix it later on by sending
/// over the lines again to the editor which takes care of things or we will build it over here
fn make_changes_to_functions(
    source_code: &[u8],
    changes_code: &[u8],
    language_config: &TSLanguageConfig,
) -> Option<String> {
    let grammar = language_config.grammar;
    let mut parser = tree_sitter::Parser::new();
    parser.set_language(grammar()).expect("to work");
    let original_tree = parser.parse(source_code, None).expect("to parse");

    let changes_tree = parser.parse(changes_code, None).expect("to parse");

    let mut original_tree_cursor = original_tree.walk();
    let changed_tree_cursor = changes_tree.walk();
    let mut reached_root = false;
    loop {
        if reached_root {
            break;
        }
        let current_node = original_tree_cursor.node();
        let node_information = current_node.kind();
        let string_value = String::from_utf8(
            source_code[current_node.byte_range().start..current_node.byte_range().end].to_vec(),
        );
        dbg!(node_information);
        let child_present = original_tree_cursor.goto_first_child();
        if child_present {
            continue;
        }
        let sibling_present = original_tree_cursor.goto_next_sibling();
        if sibling_present {
            continue;
        }
        let mut retracing = true;
        while retracing {
            if !original_tree_cursor.goto_parent() {
                retracing = false;
                reached_root = true;
            }
            let sibling_present = original_tree_cursor.goto_next_sibling();
            if sibling_present {
                retracing = false;
            }
        }
    }
    None
}
